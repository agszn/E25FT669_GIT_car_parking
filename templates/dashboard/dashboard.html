{% extends "base.html" %}

{% block title %}3D Parking View{% endblock %}
{% load static %}

{% block extra_css %}
<style>
  #parking-container {
      width: 100%;
      height: 80vh;
      border-radius: 8px;
      overflow: hidden;
      background: #111;
  }
</style>
{% endblock %}

{% block content %}
<h3 class="mb-2 text-light">3D Parking View</h3>
<p class="text-muted">Green = Available, Red = Occupied</p>
<h5 class="text-dark mt-3">Slot Status</h5>
<div id="slot-status" class="text-dark">
    A1: <span id="slot-a1">Loading...</span> |
    A2: <span id="slot-a2">Loading...</span> |
    A3: <span id="slot-a3">Loading...</span>
</div>

<div id="parking-container"></div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>

<script>
// Initial slots data from Django context (JSON safe string)
let slots = {{ parking_slots_json|safe }};

const container = document.getElementById('parking-container');

const scene = new THREE.Scene();

// Load background image as texture
const loader = new THREE.TextureLoader();
const bgTexture = loader.load('{% static 'assets/img/park.png' %}');  // Replace with your image URL
scene.background = bgTexture;  // Set the scene background to the image texture

// Camera adjustments for a more zoomed-in front view
const camera = new THREE.PerspectiveCamera(30, container.clientWidth / container.clientHeight, 0.1, 1000); // Reduced FOV for zoom
camera.position.set(0, 12, 20);  // Move the camera closer for a more zoomed-in view
camera.lookAt(0, 0, 0);  // Keep it looking directly at the center of the parking area


const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

// Resize handler
window.addEventListener('resize', () => {
    renderer.setSize(container.clientWidth, container.clientHeight);
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
});

// Lights - adding shadows for realism
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(20, 50, 30);
directionalLight.castShadow = true;
scene.add(directionalLight);

// Group to hold parking slots
const slotsGroup = new THREE.Group();
scene.add(slotsGroup);

// Function to create a slot box with larger cars and slots
// Function to create a slot box with larger cars and slots
function createSlotBox(slot) {
    const geometry = new THREE.BoxGeometry(6, 0.5, 10);  // Larger parking slots
    const material = new THREE.MeshStandardMaterial({ color: slot.is_available ? 0x2ecc71 : 0xe74c3c });

    // Add an offset to move the starting position to the left
    const xOffset = -8;  // Adjust this value to move slots more to the left

    const box = new THREE.Mesh(geometry, material);
    box.position.set((slot.col * 8) + xOffset, 0.25, -slot.row * 12);  // Apply the offset to X position
    box.castShadow = true;  // Allow shadow casting

    // Create label using canvas texture
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.font = '48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(slot.code, canvas.width / 2, canvas.height / 2 + 15);

    const texture = new THREE.CanvasTexture(canvas);
    const labelMaterial = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(labelMaterial);
    sprite.position.set((slot.col * 8) + xOffset, 0.8, -slot.row * 12);  // Adjusted label position
    sprite.scale.set(6, 2, 1);  // Increased size of label

    // Add car model if occupied
    if (!slot.is_available) {
        const carGeometry = new THREE.BoxGeometry(4, 1.8, 6);  // Adjusted for better fit in the front view
        const carMaterial = new THREE.MeshStandardMaterial({ color: 0x3498db });
        const car = new THREE.Mesh(carGeometry, carMaterial);
        car.position.set((slot.col * 8) + xOffset, 1, -slot.row * 12);  // Front view for car position
        car.castShadow = true;  // Allow car to cast shadow
        slotsGroup.add(car);
    }

    slotsGroup.add(box);
    slotsGroup.add(sprite);
}


// Draw all slots
function drawSlots(slotsData) {
    // Remove all children before redraw
    while (slotsGroup.children.length > 0) {
        const obj = slotsGroup.children[0];
        slotsGroup.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
            if (Array.isArray(obj.material)) {
                obj.material.forEach(m => m.dispose());
            } else {
                obj.material.dispose();
            }
        }
        if (obj.texture) obj.texture.dispose();
    }

    slotsData.forEach(createSlotBox);
}

// Initial draw
drawSlots(slots);

// Animate/render loop
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();

// Function to update specific slot statuses
function updateSlotStatus(slotsData) {
    const slotMap = {};
    slotsData.forEach(slot => {
        slotMap[slot.code.toLowerCase()] = slot.is_available;
    });

    document.getElementById('slot-a1').textContent = slotMap['a1'] ? 'Available' : 'Occupied';
    document.getElementById('slot-a2').textContent = slotMap['a2'] ? 'Available' : 'Occupied';
    document.getElementById('slot-a3').textContent = slotMap['a3'] ? 'Available' : 'Occupied';
}

// Modify your fetch interval to also update statuses
setInterval(() => {
    fetch('/api/slots/')
        .then(res => res.json())
        .then(data => {
            drawSlots(data);          // redraw 3D view
            updateSlotStatus(data);   // update text status
        })
        .catch(err => console.error('Error fetching slots:', err));
}, 2000);

</script>
{% endblock %}
