{% extends "base.html" %}

{% block title %}3D Parking View{% endblock %}

{% block extra_css %}
<style>
  #parking-container {
      width: 100%;
      height: 80vh;
      border-radius: 8px;
      overflow: hidden;
      background: #111;
  }
</style>
{% endblock %}

{% block content %}
<h3 class="mb-2 text-light">3D Parking View</h3>
<p class="text-muted">Green = Available, Red = Occupied</p>
<h5 class="text-dark mt-3">Slot Status</h5>
<div id="slot-status" class="text-dark">
    A1: <span id="slot-a1">Loading...</span> |
    A2: <span id="slot-a2">Loading...</span> |
    A3: <span id="slot-a3">Loading...</span>
</div>

<div id="parking-container"></div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>

<script>
// Initial slots data from Django context (JSON safe string)
let slots = {{ parking_slots_json|safe }};

const container = document.getElementById('parking-container');

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
camera.position.set(15, 30, 40);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

// Resize handler
window.addEventListener('resize', () => {
    renderer.setSize(container.clientWidth, container.clientHeight);
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
});

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(20, 30, 10);
scene.add(directionalLight);

// Group to hold parking slots
const slotsGroup = new THREE.Group();
scene.add(slotsGroup);

// Function to create a slot box
function createSlotBox(slot) {
    const geometry = new THREE.BoxGeometry(3, 0.3, 5);
    const material = new THREE.MeshStandardMaterial({ color: slot.is_available ? 0x2ecc71 : 0xe74c3c });
    const box = new THREE.Mesh(geometry, material);
    box.position.set(slot.col * 4, 0.15, slot.row * 6);
    box.userData = { code: slot.code };

    // Create label using canvas texture
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.font = '40px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(slot.code, canvas.width / 2, canvas.height / 2 + 15);

    const texture = new THREE.CanvasTexture(canvas);
    const labelMaterial = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(labelMaterial);
    sprite.position.set(slot.col * 4, 0.7, slot.row * 6);
    sprite.scale.set(4, 1, 1);

    // Add car model if occupied
    if (!slot.is_available) {
        const carGeometry = new THREE.BoxGeometry(2.5, 1.2, 4);
        const carMaterial = new THREE.MeshStandardMaterial({ color: 0x3498db });
        const car = new THREE.Mesh(carGeometry, carMaterial);
        car.position.set(slot.col * 4, 1, slot.row * 6);
        slotsGroup.add(car);
    }

    slotsGroup.add(box);
    slotsGroup.add(sprite);
}

// Draw all slots
function drawSlots(slotsData) {
    // Remove all children before redraw
    while (slotsGroup.children.length > 0) {
        const obj = slotsGroup.children[0];
        slotsGroup.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
            if (Array.isArray(obj.material)) {
                obj.material.forEach(m => m.dispose());
            } else {
                obj.material.dispose();
            }
        }
        if (obj.texture) obj.texture.dispose();
    }

    slotsData.forEach(createSlotBox);
}

// Initial draw
drawSlots(slots);

// Animate/render loop
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();

// Function to update specific slot statuses
function updateSlotStatus(slotsData) {
    const slotMap = {};
    slotsData.forEach(slot => {
        slotMap[slot.code.toLowerCase()] = slot.is_available;
    });

    document.getElementById('slot-a1').textContent = slotMap['a1'] ? 'Available' : 'Occupied';
    document.getElementById('slot-a2').textContent = slotMap['a2'] ? 'Available' : 'Occupied';
    document.getElementById('slot-a3').textContent = slotMap['a3'] ? 'Available' : 'Occupied';
}

// Modify your fetch interval to also update statuses
setInterval(() => {
    fetch('/api/slots/')
        .then(res => res.json())
        .then(data => {
            drawSlots(data);          // redraw 3D view
            updateSlotStatus(data);   // update text status
        })
        .catch(err => console.error('Error fetching slots:', err));
}, 2000);

// Live update every 2 seconds
setInterval(() => {
    fetch('/api/slots/')
        .then(res => res.json())
        .then(data => {
            drawSlots(data);
        })
        .catch(err => console.error('Error fetching slots:', err));
}, 2000);

</script>
{% endblock %}
